<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>SwampHop Album Player</title>

<style>
    body {
        margin: 0;
        background: linear-gradient(160deg, #0b0f10 0%, #1a1f1c 40%, #2f3b32 100%);
        font-family: 'Segoe UI', sans-serif;
        color: #d8e6d5;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        overflow: hidden;
    }

    .player-shell {
        display: flex;
        gap: 22px;
        padding: 26px;
        background: rgba(10, 15, 12, 0.85);
        border-radius: 26px;
        border: 1px solid rgba(133, 171, 150, 0.25);
        box-shadow:
          0 0 40px rgba(0, 0, 0, 0.8),
          inset 0 0 20px rgba(0, 0, 0, 0.45);
        max-width: 820px;
        width: 95%;
    }

    .player-container {
        background: rgba(24, 32, 27, 0.75);
        backdrop-filter: blur(8px);
        border-radius: 22px;
        padding: 24px 24px 18px 24px;
        width: 380px;
        text-align: center;
        position: relative;
        border: 1px solid rgba(133, 171, 150, 0.25);
    }

    .title {
        font-size: 1.2rem;
        letter-spacing: 0.5px;
        color: #c5dcc8;
        margin-bottom: 8px;
        font-weight: 500;
    }

    .subtitle {
        font-size: 0.9rem;
        color: #7f9b86;
        margin-bottom: 20px;
    }

    .swamp-orb {
        width: 120px;
        height: 120px;
        margin: 0 auto 22px auto;
        border-radius: 50%;
        background: radial-gradient(circle at 30% 30%, #8fbfa1, #415447, #1f2a25);
        box-shadow: 0 0 28px rgba(80, 134, 105, 0.5);
        animation: pulse 5.2s infinite ease-in-out;
        position: relative;
        overflow: hidden;
    }

    .swamp-orb::after {
        content: "";
        position: absolute;
        inset: 10%;
        border-radius: 50%;
        background: radial-gradient(circle at 70% 120%, rgba(15, 20, 18, 0.5), transparent 60%);
        mix-blend-mode: multiply;
    }

    @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
    }

    audio {
        display: none; /* Hidden - we use custom controls */
    }

    .bar {
        width: 95%;
        height: 4px;
        background: rgba(255, 255, 255, 0.15);
        border-radius: 999px;
        margin: 16px auto 10px auto;
        overflow: hidden;
        position: relative;
    }

    .bar-fill {
        width: 0%;
        height: 100%;
        background: linear-gradient(90deg, #96c7a6, #629f7a, #2f6c50);
        border-radius: 999px;
        transition: width 0.1s linear;
    }

    .controls-row {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-bottom: 4px;
        font-size: 0.85rem;
        color: #93b39a;
    }

    .ctrl-btn {
        border: 1px solid rgba(145, 185, 155, 0.4);
        background: rgba(18, 26, 22, 0.9);
        border-radius: 999px;
        padding: 4px 12px;
        cursor: pointer;
        font-size: 0.8rem;
        color: #cfe2d4;
        letter-spacing: 0.5px;
    }

    .ctrl-btn:hover {
        background: rgba(33, 48, 39, 0.9);
    }

    .ctrl-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        pointer-events: none;
    }

    .bar.locked {
        pointer-events: none;
        opacity: 0.6;
    }

    .track-item.locked {
        opacity: 0.5;
        cursor: not-allowed;
        background: rgba(10, 15, 12, 0.7);
    }

    .track-item.locked:hover {
        background: rgba(10, 15, 12, 0.7);
        transform: none;
    }

    .footer {
        font-size: 0.78rem;
        opacity: 0.6;
        margin-top: 6px;
    }

    /* Playlist pane */
    .playlist-panel {
        flex: 1;
        background: rgba(18, 24, 20, 0.9);
        border-radius: 20px;
        padding: 16px 16px 10px 16px;
        border: 1px solid rgba(133, 171, 150, 0.3);
        display: flex;
        flex-direction: column;
        min-width: 0;
    }

    .playlist-title {
        font-size: 0.95rem;
        color: #b9d3c0;
        margin-bottom: 8px;
        letter-spacing: 0.8px;
        text-transform: uppercase;
    }

    .playlist-subtitle {
        font-size: 0.8rem;
        color: #809786;
        margin-bottom: 10px;
    }

    .track-list {
        list-style: none;
        margin: 0;
        padding: 0;
        max-height: 260px;
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: #486553 transparent;
    }

    .track-list::-webkit-scrollbar {
        width: 6px;
    }

    .track-list::-webkit-scrollbar-track {
        background: transparent;
    }

    .track-list::-webkit-scrollbar-thumb {
        background: #486553;
        border-radius: 999px;
    }

    .track-item {
        padding: 8px 10px;
        margin-bottom: 4px;
        border-radius: 12px;
        font-size: 0.86rem;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: rgba(15, 22, 18, 0.7);
        border: 1px solid transparent;
        transition: background 0.15s ease, border-color 0.15s ease, transform 0.1s ease;
    }

    .track-item span {
        pointer-events: none;
    }

    .track-item:hover {
        background: rgba(33, 48, 39, 0.95);
        transform: translateY(-1px);
    }

    .track-item.active {
        border-color: rgba(151, 209, 173, 0.9);
        background: radial-gradient(circle at 0% 0%, rgba(136, 189, 155, 0.28), rgba(18, 25, 21, 0.95));
        box-shadow: 0 0 12px rgba(120, 186, 151, 0.4);
    }

    .track-index {
        color: #7a9784;
        font-size: 0.78rem;
        margin-right: 8px;
    }

    .track-name {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 210px;
    }

    .track-tag {
        font-size: 0.72rem;
        color: #90b49b;
        opacity: 0.85;
    }

    @media (max-width: 780px) {
        body {
            align-items: flex-start;
            padding-top: 20px;
            height: auto;
        }
        .player-shell {
            flex-direction: column;
            align-items: stretch;
            max-width: 480px;
        }
        .player-container {
            width: 100%;
        }
    }
</style>
</head>

<body>

<div class="player-shell">
    <!-- LEFT: main player -->
    <div class="player-container">
        <div class="swamp-orb"></div>

        <div class="title" id="currentTitle">Creed of the Maybe</div>
        <div class="subtitle" id="currentSubtitle">SwampHop • EchoVerse • Track 1</div>
        <div class="subtitle" id="currentDescription" style="font-size: 0.75rem; color: #6b8a75; margin-top: 4px; font-style: italic; line-height: 1.3; max-width: 90%; margin-left: auto; margin-right: auto;"></div>

        <audio id="audio" preload="auto" crossorigin="anonymous">
            <!-- src is set via JavaScript -->
            Your browser does not support the audio element.
        </audio>

        <div class="bar">
            <div class="bar-fill" id="barFill"></div>
        </div>

        <div class="controls-row">
            <button class="ctrl-btn" id="prevBtn">Prev</button>
            <button class="ctrl-btn" id="playPauseBtn">Play</button>
            <button class="ctrl-btn" id="nextBtn">Next</button>
        </div>

        <div class="footer">Keep walkin, even if we ain’t winnin yet.</div>
    </div>

    <!-- RIGHT: playlist -->
    <div class="playlist-panel">
        <div class="playlist-title">SwampHop Album Queue</div>
        <div class="playlist-subtitle">Loaded from /audio/ — click to play any track.</div>

        <ul class="track-list" id="trackList">
            <!-- Filled by JavaScript -->
        </ul>
    </div>
</div>

<script>
    // Configure your album here.
    // All files are expected under ./audio/
    const playlist = [
        {
            id: 'creed_of_the_maybe',
            title: "Creed of the Maybe",
            file: "Creed_of_the_Maybe.mp3",
            tag: "Track 1",
            description: "The philosophy. Boundaries. Honesty. The idea that 'maybe' is the only real answer when the path isn't drawn yet."
        },
        {
            id: 'slow_me_sink_me',
            title: "Slow Me, Sink Me, See Me Clear",
            file: "Slow_Me,_Sink_Me,_See_Me_Clear.mp3",
            tag: "Track 2",
            description: "The internal shift. Finding your own pace. Slow, steady, intentional movement. Wise leadership."
        },
        {
            id: 'walkin_not_winnin',
            title: "Walkin Even When I'm Not Winnin",
            file: "Walkin_even_when_im_not__Winnin.mp3",
            tag: "Track 3",
            description: "The invitation. 'Walk with me even if I don't have the guarantee.' Leadership without promises; motion without certainty."
        },
        {
            id: 'three_weeks_drift',
            title: "Three Weeks Deep in the Drift",
            file: "Three_Weeks_Deep_in_the_Drift.mp3",
            tag: "Track 4",
            description: "Visible progress, invisible to them. You've been showing motion for weeks — they can't see it through their fear."
        },
        {
            id: 'hearing_not_listening',
            title: "Hearing Ain't the Same as Listenin",
            file: "Hearing_Ain't_the_Same_as_Listenin.mp3",
            tag: "Track 5",
            description: "The hard truth. When fear, pressure, or manipulation stops them from hearing anything real."
        }
    ];

    const audio = document.getElementById('audio');
    const barFill = document.getElementById('barFill');
    const currentTitle = document.getElementById('currentTitle');
    const currentSubtitle = document.getElementById('currentSubtitle');
    const currentDescription = document.getElementById('currentDescription');
    const trackListEl = document.getElementById('trackList');

    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const playPauseBtn = document.getElementById('playPauseBtn');

    let currentIndex = 0;
    let isPlaying = false;

    // localStorage key for progress
    const STORAGE_KEY = 'swamphopProgress_v1';

    // Progress data model
    let progress = null;

    // localStorage Management Functions
    function loadProgress() {
        try {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (!raw) {
                return {
                    completedTracks: {},   // { [trackId]: true }
                    highestUnlockedIndex: 0, // you can start track 0
                };
            }
            return JSON.parse(raw);
        } catch (e) {
            console.warn('Error reading progress from localStorage:', e);
            return {
                completedTracks: {},
                highestUnlockedIndex: 0,
            };
        }
    }

    function saveProgress(progressData) {
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(progressData));
        } catch (e) {
            console.warn('Error saving progress to localStorage:', e);
        }
    }

    // Rules Functions
    function isTrackCompleted(index) {
        const track = playlist[index];
        if (!track) return false;
        return !!progress.completedTracks[track.id];
    }

    // Track is playable if it's within "highest unlocked + 1"
    function isTrackPlayable(index) {
        return index <= progress.highestUnlockedIndex + 1;
    }

    function canSkipCurrentSong() {
        // Can skip if current song is completed
        return isTrackCompleted(currentIndex);
    }

    // Web Audio API setup for UHD quality and deep bass
    let audioContext = null;
    let sourceNode = null;
    let gainNode = null;
    let bassBoost = null;
    let lowShelf = null;
    let highShelf = null;
    let compressor = null;
    let destination = null;

    // Initialize Web Audio API
    function initAudioContext() {
        if (!audioContext) {
            try {
                const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioContextClass({
                    sampleRate: 48000, // High quality sample rate
                    latencyHint: 'interactive'
                });

                // Create audio processing chain for deep bass and UHD quality
                // Note: createMediaElementSource can only be called once per audio element
                // Disconnect the audio element from its default destination first
                if (!sourceNode) {
                    try {
                        sourceNode = audioContext.createMediaElementSource(audio);
                    } catch (err) {
                        // If source already created, we'll need to reconnect
                        console.warn('MediaElementSource may already exist:', err);
                        return;
                    }
                }
                
                // Compressor for dynamic range control
                compressor = audioContext.createDynamicsCompressor();
                compressor.threshold.value = -24;
                compressor.knee.value = 30;
                compressor.ratio.value = 12;
                compressor.attack.value = 0.003;
                compressor.release.value = 0.25;

                // Low shelf filter for deep bass boost (20-80Hz)
                lowShelf = audioContext.createBiquadFilter();
                lowShelf.type = 'lowshelf';
                lowShelf.frequency.value = 60; // Focus on sub-bass
                lowShelf.gain.value = 8; // Significant bass boost
                lowShelf.Q.value = 0.7;

                // Bass boost filter (80-200Hz)
                bassBoost = audioContext.createBiquadFilter();
                bassBoost.type = 'peaking';
                bassBoost.frequency.value = 120; // Mid-bass frequency
                bassBoost.gain.value = 6; // Boost mid-bass
                bassBoost.Q.value = 1.0;

                // High shelf for clarity and presence
                highShelf = audioContext.createBiquadFilter();
                highShelf.type = 'highshelf';
                highShelf.frequency.value = 8000; // High frequencies
                highShelf.gain.value = 2; // Slight boost for clarity
                highShelf.Q.value = 0.7;

                // Master gain control
                gainNode = audioContext.createGain();
                gainNode.gain.value = 1.0;

                // Connect the audio processing chain
                sourceNode.connect(compressor);
                compressor.connect(lowShelf);
                lowShelf.connect(bassBoost);
                bassBoost.connect(highShelf);
                highShelf.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // Resume audio context if suspended (required by some browsers)
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            } catch (error) {
                console.warn('Web Audio API not available, using standard audio:', error);
            }
        }
    }

    // Ensure audio context is initialized on user interaction
    function ensureAudioContext() {
        if (!audioContext || audioContext.state === 'closed') {
            initAudioContext();
        } else if (audioContext.state === 'suspended') {
            audioContext.resume();
        }
    }

    // UI State Management
    function updateUIState() {
        // Lock/unlock next/prev for THIS track
        const completed = isTrackCompleted(currentIndex);

        // Next/Prev:
        // - No skipping forward until current is completed
        // - No jumping to tracks past highestUnlockedIndex + 1
        nextBtn.disabled = !completed || currentIndex >= playlist.length - 1;
        prevBtn.disabled = !completed || currentIndex <= 0;

        // Seek bar:
        // - Locked (read-only) until this track has been completed once
        const bar = document.querySelector('.bar');
        if (completed) {
            bar.classList.remove('locked');
            audio.removeAttribute('data-seek-locked');
        } else {
            bar.classList.add('locked');
            audio.setAttribute('data-seek-locked', 'true');
        }
    }

    function buildPlaylistUI() {
        trackListEl.innerHTML = "";
        playlist.forEach((track, index) => {
            const li = document.createElement('li');
            li.className = 'track-item';
            li.dataset.index = index;

            const canPlay = isTrackPlayable(index);
            if (!canPlay) {
                li.classList.add('locked');
            }

            li.innerHTML = `
                <span>
                    <span class="track-index">${index + 1}</span>
                    <span class="track-name">${track.title}</span>
                </span>
                <span class="track-tag">${track.tag || ""}</span>
            `;
            
            // Add description as tooltip if available
            let tooltip = track.description || '';
            if (!canPlay) {
                const firstIncomplete = findFirstIncomplete(index);
                if (firstIncomplete !== null) {
                    tooltip = `Complete "${playlist[firstIncomplete].title}" first to unlock this track. ${tooltip ? '\n\n' + tooltip : ''}`;
                }
            }
            if (tooltip) {
                li.title = tooltip;
            }

            li.addEventListener('click', () => {
                if (canPlay) {
                    loadTrack(index, true);
                }
            });

            trackListEl.appendChild(li);
        });
    }

    function findFirstIncomplete(upToIndex) {
        for (let i = 0; i < upToIndex; i++) {
            if (!isTrackCompleted(i)) {
                return i;
            }
        }
        return null;
    }

    function updateActiveTrackUI() {
        const items = trackListEl.querySelectorAll('.track-item');
        items.forEach(item => {
            const idx = Number(item.dataset.index);
            if (idx === currentIndex) {
                item.classList.add('active');
            } else {
                item.classList.remove('active');
            }
        });
    }

    function loadTrack(index, autoPlay = false) {
        if (index < 0 || index >= playlist.length) return;
        
        // Enforce order: can't jump ahead of unlocked window
        if (!isTrackPlayable(index)) {
            alert('You need to finish the earlier tracks before this one will unlock.');
            return;
        }
        
        currentIndex = index;
        const track = playlist[currentIndex];
        
        // Ensure Web Audio API is initialized
        ensureAudioContext();
        
        // Set audio source with high quality settings
        audio.src = 'audio/' + track.file;  // expects /audio/ folder
        audio.preload = 'auto'; // Preload for smooth playback
        
        currentTitle.textContent = track.title;
        currentSubtitle.textContent = `SwampHop • EchoVerse • ${track.tag || "Track"}`;
        
        // Display description if available
        if (track.description) {
            currentDescription.textContent = track.description;
            currentDescription.style.display = 'block';
        } else {
            currentDescription.textContent = '';
            currentDescription.style.display = 'none';
        }

        updateActiveTrackUI();
        updateUIState();
        barFill.style.width = '0%';
        
        // Reset last safe time for seek lock
        audio._lastSafeTime = 0;

        // Wait for metadata to load before playing
        audio.addEventListener('loadedmetadata', function onMetadataLoaded() {
            audio.removeEventListener('loadedmetadata', onMetadataLoaded);
            if (autoPlay) {
                ensureAudioContext();
                audio.play().catch((err) => {
                    console.warn('Playback error:', err);
                });
                isPlaying = true;
                playPauseBtn.textContent = 'Pause';
            } else {
                isPlaying = false;
                playPauseBtn.textContent = 'Play';
            }
        }, { once: true });
    }


    audio.addEventListener('ended', () => {
        const track = playlist[currentIndex];
        
        // Mark track as completed using track ID
        progress.completedTracks[track.id] = true;
        
        // Bump highestUnlockedIndex if we just finished the furthest track so far
        if (currentIndex > progress.highestUnlockedIndex) {
            progress.highestUnlockedIndex = currentIndex;
        }
        
        // Save progress
        saveProgress(progress);
        
        // Update UI states (unlock next song, unlock skipping for completed song)
        updateUIState();
        buildPlaylistUI(); // Refresh playlist to show newly unlocked tracks
        updateActiveTrackUI(); // Restore active state
        
        // Auto-advance to next track if available and playable
        if (currentIndex < playlist.length - 1) {
            if (isTrackPlayable(currentIndex + 1)) {
                loadTrack(currentIndex + 1, true);
            } else {
                // Next song not yet unlocked
                isPlaying = false;
                playPauseBtn.textContent = 'Play';
            }
        } else {
            // End of album
            isPlaying = false;
            playPauseBtn.textContent = 'Play';
        }
    });

    // Handle play/pause state changes from native controls
    audio.addEventListener('play', () => {
        ensureAudioContext();
        isPlaying = true;
        playPauseBtn.textContent = 'Pause';
    });

    audio.addEventListener('pause', () => {
        isPlaying = false;
        playPauseBtn.textContent = 'Play';
    });

    // Handle audio errors
    audio.addEventListener('error', (e) => {
        console.error('Audio error:', e);
        const track = playlist[currentIndex];
        console.error('Failed to load:', track.file);
        alert(`Error loading track: ${track.title}\n\nPlease check that the file exists: audio/${track.file}`);
    });

    // Remove native controls to prevent seeking via browser controls
    audio.controls = false;
    
    // Track furthest legit point reached for forward-only progress
    if (!audio._lastSafeTime) {
        audio._lastSafeTime = 0;
    }
    
    // Update progress bar and track safe time
    audio.addEventListener('timeupdate', () => {
        // Keep track of the furthest legit point they've reached
        audio._lastSafeTime = audio.currentTime;
        
        if (!isNaN(audio.duration)) {
            const percent = (audio.currentTime / audio.duration) * 100;
            barFill.style.width = percent + '%';
        }
    });

    // Block seeking if track not completed
    audio.addEventListener('seeking', () => {
        if (!isTrackCompleted(currentIndex)) {
            // Block forward-seeking
            if (audio.currentTime > audio._lastSafeTime) {
                audio.currentTime = audio._lastSafeTime || 0;
            }
        }
    });

    // Prevent progress bar clicks from seeking when locked
    const bar = document.querySelector('.bar');
    bar.addEventListener('click', (e) => {
        if (audio.getAttribute('data-seek-locked') === 'true') {
            e.stopPropagation();
            e.preventDefault();
            return false;
        }
        
        // Allow seeking if unlocked
        const rect = bar.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const percent = clickX / rect.width;
        if (!isNaN(audio.duration)) {
            audio.currentTime = percent * audio.duration;
        }
    });

    prevBtn.addEventListener('click', () => {
        if (prevBtn.disabled) return;
        
        if (currentIndex > 0) {
            loadTrack(currentIndex - 1, true);
        } else {
            loadTrack(playlist.length - 1, true); // wrap to last
        }
    });

    nextBtn.addEventListener('click', () => {
        if (nextBtn.disabled) return;
        
        if (currentIndex < playlist.length - 1) {
            loadTrack(currentIndex + 1, true);
        } else {
            loadTrack(0, true); // wrap to first
        }
    });

    playPauseBtn.addEventListener('click', () => {
        ensureAudioContext();
        if (!isPlaying) {
            audio.play().catch((err) => {
                console.warn('Playback error:', err);
            });
            isPlaying = true;
            playPauseBtn.textContent = 'Pause';
        } else {
            audio.pause();
            isPlaying = false;
            playPauseBtn.textContent = 'Play';
        }
    });

    // Initialize audio context on any user interaction
    document.addEventListener('click', ensureAudioContext, { once: true });
    document.addEventListener('touchstart', ensureAudioContext, { once: true });
    document.addEventListener('keydown', ensureAudioContext, { once: true });

    // Initialize on page load
    function initialize() {
        // Load progress from localStorage
        progress = loadProgress();
        
        // Build playlist UI with locked states
        buildPlaylistUI();
        
        // Load first track (always playable)
        loadTrack(0, false);
        
        // Set initial UI states
        updateUIState();
    }

    // Init
    initialize();
</script>

</body>
</html>
